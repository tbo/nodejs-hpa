{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/diff-dom/src/TraceLogger.js","webpack:///./node_modules/diff-dom/src/diffDOM/dom/apply.js","webpack:///./node_modules/diff-dom/src/diffDOM/dom/fromVirtual.js","webpack:///./node_modules/diff-dom/src/diffDOM/dom/index.js","webpack:///./node_modules/diff-dom/src/diffDOM/dom/undo.js","webpack:///./node_modules/diff-dom/src/diffDOM/index.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/apply.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/diff.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/fromDOM.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/fromString.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/helpers.js","webpack:///./node_modules/diff-dom/src/diffDOM/virtual/index.js","webpack:///./node_modules/diff-dom/src/index.js","webpack:///./node_modules/morphdom/dist/morphdom-esm.js","webpack:///./node_modules/nanoassert/index.js","webpack:///./node_modules/nanomorph/index.js","webpack:///./node_modules/nanomorph/lib/events.js","webpack:///./node_modules/nanomorph/lib/morph.js","webpack:///./node_modules/snabbdom/es/h.js","webpack:///./node_modules/snabbdom/es/htmldomapi.js","webpack:///./node_modules/snabbdom/es/is.js","webpack:///./node_modules/snabbdom/es/snabbdom.js","webpack:///./node_modules/snabbdom/es/thunk.js","webpack:///./node_modules/snabbdom/es/vnode.js","webpack:///./node_modules/snabbdom/htmldomapi.js","webpack:///./node_modules/snabbdom/modules/attributes.js","webpack:///./node_modules/snabbdom/modules/class.js","webpack:///./node_modules/snabbdom/modules/eventlisteners.js","webpack:///./node_modules/snabbdom/modules/props.js","webpack:///./node_modules/snabbdom/modules/style.js","webpack:///./node_modules/snabbdom/tovnode.js","webpack:///./node_modules/snabbdom/vnode.js","webpack:///./src/hybrid.ts"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,wBAAwB,EAAE;AAC1B;AACA;AACA;AACA,kBAAkB,SAAS,IAAI,aAAa,EAAE,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB,IAAI,WAAW;AAC1D;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAuC;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAO;AACP;AACA;AACA;;AAEA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACF;;;;;;;;;;;;;ACD9B;AAAA;AAAA;AAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA,YAAY,wDAAS;AACrB;AACA;AACA;AACA;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACH;AACY;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+BAA+B,KAAK,EAAE;AACtC,4BAA4B;AAC5B,6BAA6B;AAC7B,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;;AAGO;AACP,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA,0BAA0B,yDAAU;;AAEpC;;AAEA;AACA,eAAe,2DAAQ;AACvB;;AAEA;AACA,eAAe,0DAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAkC;;AAElC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACjSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyH;AACrF;AACD;AACK;;AAExC;;AAEO;AACP;AACA;AACA,oDAAoD,0DAAS,wDAAwD,+DAAW;AAChI,oDAAoD,0DAAS,wDAAwD,+DAAW;AAChI;AACA;AACA;AACA,0BAA0B,0DAAS;AACnC,0BAA0B,0DAAS;AACnC;;AAEA,2BAA2B,oDAAW;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,4BAA4B,MAAM,4BAA4B;AACvH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,wDAAO;AAC5B;AACA;AACA,qBAAqB;AACrB;AACA,wBAAwB,2DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2DAAY;AAC5B;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA,wDAAwD,yDAAQ;AAChE,wDAAwD,yDAAQ;AAChE;AACA;AACA;AACA;AACA,wBAAwB,6CAAI;AAC5B;AACA,wDAAwD,yDAAQ;AAChE,wDAAwD,yDAAQ;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,6CAAI;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,4BAA4B,6CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,+BAA+B,6CAAI;AACnC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC,6CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,6DAAY;;AAEzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uCAAuC,6CAAI;AAC3C;AACA;AACA,mEAAmE,yDAAQ;AAC3E;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA,uCAAuC,6CAAI;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB,uCAAuC,6CAAI;AAC3C;AACA;AACA,mEAAmE,yDAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,WAAW,wDAAO;AACnC;AACA;AACA,gCAAgC,6CAAI;AACpC;AACA,uEAAuE,yDAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,gCAAgC,6CAAI;AACpC;AACA,uEAAuE,yDAAQ;AAC/E;AACA;AACA,oDAAoD;AACpD;AACA,qBAAqB;AACrB;AACA,gCAAgC,6CAAI;AACpC;AACA,wEAAwE,yDAAQ;AAChF,wEAAwE,yDAAQ;AAChF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6CAAI;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mCAAmC,6CAAI;AACvC;AACA;AACA,+DAA+D,yDAAQ;AACvE;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA,mCAAmC,6CAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mCAAmC,6CAAI;AACvC;AACA;AACA,+DAA+D,yDAAQ;AACvE;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD,6BAA6B,6DAAY;AACzC;AACA;AACA;AACA;AACA,oCAAoC,6CAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;ACrdA;AAAA;AAAO,sCAAsC;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,+BAA+B,sBAAsB;AACrD,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,GAAG,0CAA0C;AACxF;AACA;AACA,+BAA+B,YAAY,GAAG,iBAAiB;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb,wCAAwC,YAAY,GAAG,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,GAAG,0CAA0C;AAChG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGO,wBAAwB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,yBAAyB,oBAAoB;AAC7C;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,YAAY;AACjD;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACE;AACK;;;;;;;;;;;;;ACFxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+D;AACtB;;;;;;;;;;;;;ACDzC;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB,oBAAoB,KAAK;AACzB,oBAAoB,QAAQ;AAC5B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa,8EAA8E;AAC3F;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;ACtuBxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACrBA,aAAa,mBAAO,CAAC,sDAAY;AACjC,YAAY,mBAAO,CAAC,0DAAa;;AAEjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,qBAAqB,+BAA+B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA,aAAa,mBAAO,CAAC,wDAAU;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA,sBAAsB;AACtB;AACA,KAAK,wBAAwB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;;;;;;;;;;;ACnKA;AAAA;AAAA;AAAA;AAAgC;AACL;AAC3B;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iBAAiB;AACjB;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,gBAAgB,6CAAY;AAC5B,8BAA8B,oDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAK;AAChB;AACA;AACe,gEAAC,EAAC;AACjB,6B;;;;;;;;;;;;ACvDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,yEAAU,EAAC;AAC1B,sC;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAO;AACA;AACP;AACA;AACA,8B;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACD;AACW;AACtC,qBAAqB,wBAAwB;AAC7C,mBAAmB,wBAAwB;AAC3C,gBAAgB,sDAAK,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACQ;AACzB;AACP;AACA,8CAA8C,mDAAU;AACxD,eAAe,kBAAkB;AACjC;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAK,4CAA4C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,gBAAgB,yCAAQ;AACxB,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAY;AACjC;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,oC;;;;;;;;;;;;AClTA;AAAA;AAAA;AAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAC;AACZ;AACA,eAAe,iCAAiC;AAChD;AACA;AACA,KAAK;AACL;AACe,oEAAK,EAAC;AACrB,iC;;;;;;;;;;;;AC5CA;AAAA;AAAO;AACP;AACA,YAAY;AACZ;AACe,oEAAK,EAAC;AACrB,iC;;;;;;;;;;;;ACLa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;ACjEa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,sC;;;;;;;;;;;;ACtDa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,iC;;;;;;;;;;;;ACxBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;;;;;;AC9Fa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,iC;;;;;;;;;;;;ACzBa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,+BAA+B,kBAAkB,SAAS,EAAE,EAAE;AAC9D;AACA;AACA,2BAA2B,iBAAiB,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;AC/Fa;AACb,8CAA8C,cAAc;AAC5D,cAAc,mBAAO,CAAC,iDAAS;AAC/B,mBAAmB,mBAAO,CAAC,2DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA,qCAAqC,eAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mC;;;;;;;;;;;;AC3Ca;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;ACRA,wHAAgC;AAChC,+GAAkC;AAClC,+FAAmC;AACnC,6GAAqC;AACrC,qHAAuC;AAGvC,MAAM,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC;IAC1B,0CAA0C;IAC1C,mBAAO,CAAC,wEAAwB,CAAC,CAAC,OAAO;IACzC,mBAAO,CAAC,wEAAwB,CAAC,CAAC,OAAO;IACzC,mBAAO,CAAC,wEAAwB,CAAC,CAAC,OAAO;IACzC,mBAAO,CAAC,0FAAiC,CAAC,CAAC,OAAO;IAClD,mBAAO,CAAC,kFAA6B,CAAC,CAAC,OAAO;CAC/C,CAAC,CAAC;AAEH,IAAI,WAAkB,CAAC;AAEvB,MAAM,MAAM,GAAG,UAA+D,CAAC;AAC/E,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;AAEhC,MAAM,EAAE,GAAG,IAAI,kBAAO,EAAE,CAAC;AAEzB,MAAM,WAAW,GAAG,CAAC,IAAU,EAAW,EAAE;;IAC1C,IAAI,QAAQ,GAAG,IAAI,CAAC;IACpB,OAAO,QAAQ,IAAI,QAAQ,CAAC,QAAQ,KAAK,GAAG,EAAE;QAC5C,QAAQ,GAAG,QAAQ,CAAC,UAAkB,CAAC;KACxC;IACD,OAAO,QAAQ,IAAI,CAAC,CAAC,YAAC,MAAC,QAA8B,EAAC,YAAY,mDAAG,MAAM,wCAAK,EAAE,EAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACrG,CAAC,CAAC;AAEF,MAAM,WAAW,GAAG,CAAC,IAAU,EAA4B,EAAE,CAC3D,IAAI,CAAC,QAAQ,KAAK,OAAO,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC,QAAQ,CAAE,IAAyB,CAAC,IAAI,CAAC,CAAC;AAEvG,IAAI,KAAY,CAAC;AACjB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC;AAEpD,MAAM,eAAe,GAAG;IACtB,iBAAiB,EAAE,CAAC,IAAU,EAAE,EAAQ,EAAE,EAAE;QAC1C,IACE,IAAI,KAAK,QAAQ,CAAC,aAAa;YAC/B,WAAW,CAAC,IAAI,CAAC;YACjB,WAAW,CAAC,EAAE,CAAC;YACf,IAAI,CAAC,KAAK,KAAK,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,EACzC;YACA,OAAO,KAAK,CAAC;SACd;QACD,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;IAC/B,CAAC;CACF,CAAC;AAEF,IAAI,eAAe,GAA2B,IAAI,CAAC;AAEnD,MAAM,MAAM,GAAG,IAAI,SAAS,EAAE,CAAC;AAE/B,MAAM,qBAAqB,GAAG,CAAI,QAAsB,EAAc,EAAE,CACtE,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAEzG,MAAM,aAAa,GAAG,CAAC,OAAgB,EAAE,IAAyB,EAAE,SAA0B,EAAE,EAAE,CAAC,KAAK,EACtG,QAA8B,EAC9B,EAAE;;IACF,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO;KACR;IACD,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,CAAC;IAC3C,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAChC,IAAI,eAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,0CAAE,OAAO,CAAC,WAAW,OAAM,CAAC,CAAC,EAAE;QACrE,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC;QACpC,OAAO;KACR;IACD,MAAM,MAAM,GAAG,MAAM,CAAC,eAAe,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IACzD,6EAA6E;IAC7E,wEAAwE;IACxE,wCAAwC;IACxC,IAAI,SAAS,CAAC,MAAM,CAAC,OAAO,EAAE;QAC5B,OAAO;KACR;IACD,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,KAAK,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;QAClC,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;YAC3B,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;SAClC;QACD,SAAS,CAAC,KAAK,EAAE,CAAC;KACnB;IACD,QAAQ,MAAM,EAAE;QACd,KAAK,WAAW;YACd,mBAAS,CAAC,QAAQ,CAAC,eAAe,EAAE,MAAM,CAAC,eAAe,CAAC,CAAC;YAC5D,MAAM;QACR,KAAK,UAAU;YACb,kBAAQ,CAAC,QAAQ,CAAC,eAAe,EAAE,MAAM,CAAC,eAAe,EAAE,eAAe,CAAC,CAAC;YAC5E,MAAM;QACR,KAAK,SAAS,CAAC,CAAC;YACd,MAAM,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,MAAM,CAAC,eAAe,CAAC,CAAC;YACvE,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YACrC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;YACzC,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YACnC,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE,QAAQ,GAAG,UAAU,CAAC,CAAC;YACxD,MAAM;SACP;QACD,KAAK,UAAU,CAAC,CAAC;YACf,MAAM,OAAO,GAAG,iBAAO,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;YAChD,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YACrC,KAAK,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YAC5B,WAAW,GAAG,OAAO,CAAC;YACtB,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YACnC,OAAO,CAAC,IAAI,CAAC,kBAAkB,EAAE,QAAQ,GAAG,UAAU,CAAC,CAAC;YACxD,MAAM;SACP;KACF;IACD,MAAM,GAAG,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IAC9B,OAAO,CAAC,IAAI,CAAC,iBAAiB,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC;IAC7C,OAAO,QAAQ,CAAC,GAAG,CAAC;AACtB,CAAC,CAAC;AAEF,MAAM,gBAAgB,GAAG,KAAK,EAAE,SAAiB,EAAE,EAAE;;IACnD,qBAAe,0CAAE,KAAK,GAAG;IACzB,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC;IACxC,MAAM,SAAS,GAAG,IAAI,eAAe,EAAE,CAAC;IACxC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IAC1C,MAAM,OAAO,GAAG,IAAI,OAAO,CAAC,SAAS,EAAE;QACrC,WAAW,EAAE,aAAa;QAC1B,QAAQ,EAAE,QAAQ;QAClB,MAAM,EAAE,eAAe,CAAC,MAAM;KAC/B,CAAC,CAAC;IACH,MAAM,gBAAgB,SAAG,KAAK,0CAC1B,KAAK,CAAC,OAAO,EACd,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,CAAC,EAC/C,KAAK,CAAC,KAAK,CAAC,EAAE;QACb,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;YAC/B,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,sBAAsB,SAAS,+BAA+B,CAAC,CAAC;YACrF,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAG,SAAS,CAAC;SAClC;IACH,CAAC,CAAC,CAAC;IACL,MAAM,iBAAiB,GAAG,KAAK,CAAC,OAAO,CAAC;SACrC,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;SAClD,KAAK,CAAC,KAAK,CAAC,EAAE;QACb,IAAI,KAAK,CAAC,IAAI,KAAK,YAAY,EAAE;YAC/B,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,sBAAsB,SAAS,+BAA+B,CAAC,CAAC;YACrF,MAAM,CAAC,QAAQ,CAAC,IAAI,GAAG,SAAS,CAAC;SAClC;IACH,CAAC,CAAC,CAAC;IACL,OAAO,qBAAqB,CAAC,CAAC,gBAAgB,EAAE,iBAAiB,CAAC,CAAC,CAAC;AACtE,CAAC,CAAC;AAEF,MAAM,UAAU,GAAG,KAAK,EAAE,SAAiB,EAAE,EAAE;IAC7C,8DAA8D;IAC9D,MAAM,QAAQ,GAAG,MAAM,gBAAgB,CAAC,SAAS,CAAC,CAAC;IACnD,IAAI,QAAQ,EAAE;QACZ,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACzD,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACvB;AACH,CAAC,CAAC;AAEF,MAAM,WAAW,GAAG,KAAK,EAAE,KAAY,EAAE,EAAE;;IACzC,IAAI,YAAK,0CAAE,MAAM,KAAI,WAAW,CAAC,KAAK,CAAC,MAAc,CAAC,EAAE;QACtD,KAAK,CAAC,cAAc,EAAE,CAAC;QACvB,UAAU,OAAE,KAAK,CAAC,MAA4B,CAAC,YAAY,CAAC,MAAM,CAAC,uCAAI,EAAE,GAAC,CAAC;KAC5E;AACH,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,KAAK,EAAE,KAAY,EAAE,EAAE;IAC1C,KAAK,CAAC,cAAc,EAAE,CAAC;IACvB,MAAM,IAAI,GAAG,KAAK,CAAC,MAAyB,CAAC;IAC7C,MAAM,KAAK,GAAG,IAAI,eAAe,CAAC,IAAI,QAAQ,CAAC,IAAI,CAAQ,CAAC,CAAC,QAAQ,EAAE,CAAC;IACxE,MAAM,UAAU,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC;AAEF,QAAQ,CAAC,gBAAgB,CAAC,kBAAkB,EAAE;IAC5C,WAAW,GAAG,iBAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,CAAC;IAChD,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,WAAW,CAAC,CAAC;IAChD,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;IAClD,MAAM,CAAC,UAAU,GAAG,CAAC,KAAoB,EAAE,EAAE,WAAC,uBAAgB,CAAC,CAAC,WAAK,0CAAE,MAAiB,EAAC,QAAQ,CAAC,IAAI,CAAC,IAAC;AAC1G,CAAC,CAAC,CAAC","file":"hybrid.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/hybrid.ts\");\n","/**\n * Use TraceLogger to figure out function calls inside\n * JS objects by wrapping an object with a TraceLogger\n * instance.\n *\n * Pretty-prints the call trace (using unicode box code)\n * when tracelogger.toString() is called.\n */\n\n/**\n * Wrap an object by calling new TraceLogger(obj)\n *\n * If you're familiar with Python decorators, this\n * does roughly the same thing, adding pre/post\n * call hook logging calls so that you can see\n * what's going on.\n */\nexport class TraceLogger {\n    constructor(obj = {}) {\n        this.pad = \"│   \"\n        this.padding = \"\"\n        this.tick = 1\n        this.messages = []\n        const wrapkey = (obj, key) => {\n            // trace this function\n            const oldfn = obj[key]\n            obj[key] = (...args) => {\n                this.fin(key, Array.prototype.slice.call(args))\n                const result = oldfn.apply(obj, args)\n                this.fout(key, result)\n                return result\n            }\n        }\n        // can't use Object.keys for prototype walking\n        for (let key in obj) {\n            if (typeof obj[key] === \"function\") {\n                wrapkey(obj, key)\n            }\n        }\n        this.log(\"┌ TRACELOG START\")\n    }\n    // called when entering a function\n    fin(fn, args) {\n        this.padding += this.pad\n        this.log(`├─> entering ${fn}`, args)\n    }\n    // called when exiting a function\n    fout(fn, result) {\n        this.log(\"│<──┘ generated return value\", result)\n        this.padding = this.padding.substring(0, this.padding.length - this.pad.length)\n    }\n    // log message formatting\n    format(s, tick) {\n        let nf = function(t) {\n            t = `${t}`\n            while (t.length < 4) {\n                t = `0${t}`\n            }\n            return t\n        }\n        return `${nf(tick)}> ${this.padding}${s}`\n    }\n    // log a trace message\n    log() {\n        let s = Array.prototype.slice.call(arguments)\n        const stringCollapse = function(v) {\n            if (!v) {\n                return \"<falsey>\"\n            }\n            if (typeof v === \"string\") {\n                return v\n            }\n            if (v instanceof HTMLElement) {\n                return v.outerHTML || \"<empty>\"\n            }\n            if (v instanceof Array) {\n                return `[${v.map(stringCollapse).join(\",\")}]`\n            }\n            return v.toString() || v.valueOf() || \"<unknown>\"\n        }\n        s = s.map(stringCollapse).join(\", \")\n        this.messages.push(this.format(s, this.tick++))\n    }\n    // turn the log into a structured string with\n    // unicode box codes to make it a sensible trace.\n    toString() {\n        let cap = \"×   \"\n        let terminator = \"└───\"\n        while (terminator.length <= this.padding.length + this.pad.length) {\n            terminator += cap\n        }\n        let _ = this.padding\n        this.padding = \"\"\n        terminator = this.format(terminator, this.tick)\n        this.padding = _\n        return `${this.messages.join(\"\\n\")}\\n${terminator}`\n    }\n}\n","import {objToNode} from \"./fromVirtual\"\n\n// ===== Apply a diff =====\n\nfunction getFromRoute(node, route) {\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        const c = route.splice(0, 1)[0]\n        node = node.childNodes[c]\n    }\n    return node\n}\n\nexport function applyDiff(\n        tree,\n        diff,\n        options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n    ) {\n    let node = getFromRoute(tree, diff[options._const.route])\n    let newNode\n    let reference\n    let route\n    let nodeArray\n    let c\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(diff[options._const.name], diff[options._const.value])\n            break\n        case options._const.modifyAttribute:\n            if (!node || !node.setAttribute) {\n                return false\n            }\n            node.setAttribute(diff[options._const.name], diff[options._const.newValue])\n            if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                node.value = diff[options._const.newValue]\n            }\n            break\n        case options._const.removeAttribute:\n            if (!node || !node.removeAttribute) {\n                return false\n            }\n            node.removeAttribute(diff[options._const.name])\n            break\n        case options._const.modifyTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\n            break\n        case options._const.modifyValue:\n            if (!node || typeof node.value === 'undefined') {\n                return false\n            }\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            if (!node || typeof node.data === 'undefined') {\n                return false\n            }\n            options.textDiff(node, node.data, diff[options._const.oldValue], diff[options._const.newValue])\n            break\n        case options._const.modifyChecked:\n            if (!node || typeof node.checked === 'undefined') {\n                return false\n            }\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            if (!node || typeof node.selected === 'undefined') {\n                return false\n            }\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            node.parentNode.replaceChild(\n                objToNode(\n                    diff[options._const.newValue],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node\n            )\n            break\n        case options._const.relocateGroup:\n            nodeArray = Array(...new Array(diff.groupLength)).map(() => node.removeChild(node.childNodes[diff[options._const.from]]))\n            nodeArray.forEach((childNode, index) => {\n                if (index === 0) {\n                    reference = node.childNodes[diff[options._const.to]]\n                }\n                node.insertBefore(childNode, reference || null)\n            })\n            break\n        case options._const.removeElement:\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromRoute(tree, route)\n            node.insertBefore(\n                objToNode(\n                    diff[options._const.element],\n                    node.namespaceURI === 'http://www.w3.org/2000/svg',\n                    options\n                ),\n                node.childNodes[c] || null\n            )\n            break\n        case options._const.removeTextElement:\n            if (!node || node.nodeType !== 3) {\n                return false\n            }\n            node.parentNode.removeChild(node)\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = options.document.createTextNode(diff[options._const.value])\n            node = getFromRoute(tree, route)\n            if (!node || !node.childNodes) {\n                return false\n            }\n            node.insertBefore(newNode, node.childNodes[c] || null)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    // if a new node was created, we might be interested in its\n    // post diff hook\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return true\n}\n\nexport function applyDOM(tree, diffs, options) {\n    return diffs.every(diff => applyDiff(tree, diff, options))\n}\n","export function objToNode(objNode, insideSvg, options) {\n    let node\n    if (objNode.nodeName === '#text') {\n        node = options.document.createTextNode(objNode.data)\n\n    } else if (objNode.nodeName === '#comment') {\n        node = options.document.createComment(objNode.data)\n    } else {\n        if (objNode.nodeName === 'svg' || insideSvg) {\n            node = options.document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName)\n            insideSvg = true\n        } else {\n            node = options.document.createElement(objNode.nodeName)\n        }\n        if (objNode.attributes) {\n            Object.entries(objNode.attributes).forEach(([key, value]) => node.setAttribute(key, value))\n        }\n        if (objNode.childNodes) {\n            objNode.childNodes.forEach(childNode => node.appendChild(objToNode(childNode, insideSvg, options)))\n        }\n        if (options.valueDiffing) {\n            if (objNode.value) {\n                node.value = objNode.value\n            }\n            if (objNode.checked) {\n                node.checked = objNode.checked\n            }\n            if (objNode.selected) {\n                node.selected = objNode.selected\n            }\n        }\n    }\n    return node\n}\n","export {applyDOM} from \"./apply\"\nexport {undoDOM} from \"./undo\"\n","import {applyDiff} from \"./apply\"\n\n// ===== Undo a diff =====\n\nfunction swap(obj, p1, p2) {\n    const tmp = obj[p1]\n    obj[p1] = obj[p2]\n    obj[p2] = tmp\n}\n\nfunction undoDiff(\n    tree,\n    diff,\n    options // {preDiffApply, postDiffApply, textDiff, valueDiffing, _const}\n) {\n\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            diff[options._const.action] = options._const.removeAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyAttribute:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeAttribute:\n            diff[options._const.action] = options._const.addAttribute\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyTextElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyValue:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyComment:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifyChecked:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.modifySelected:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.replaceElement:\n            swap(diff, options._const.oldValue, options._const.newValue)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.relocateGroup:\n            swap(diff, options._const.from, options._const.to)\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeElement:\n            diff[options._const.action] = options._const.addElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addElement:\n            diff[options._const.action] = options._const.removeElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.removeTextElement:\n            diff[options._const.action] = options._const.addTextElement\n            applyDiff(tree, diff, options)\n            break\n        case options._const.addTextElement:\n            diff[options._const.action] = options._const.removeTextElement\n            applyDiff(tree, diff, options)\n            break\n        default:\n            console.log('unknown action')\n    }\n\n}\n\nexport function undoDOM(tree, diffs, options) {\n    if (!diffs.length) {\n        diffs = [diffs]\n    }\n    diffs = diffs.slice()\n    diffs.reverse()\n    diffs.forEach(diff => {\n        undoDiff(tree, diff, options)\n    })\n}\n","import {applyDOM, undoDOM} from \"./dom/index\"\nimport {DiffFinder} from \"./virtual/index\"\nexport {nodeToObj, stringToObj} from \"./virtual/index\"\n\nconst DEFAULT_OPTIONS = {\n    debug: false,\n    diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n    maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n    maxChildCount: 50, // False or a numeral. If set to a numeral, only does a simplified form of diffing of contents so that the number of diffs cannot be higher than the number of child nodes.\n    valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n    // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n    textDiff(node, currentValue, expectedValue, newValue) {\n        node.data = newValue\n        return\n    },\n    // empty functions were benchmarked as running faster than both\n    // `f && f()` and `if (f) { f(); }`\n    preVirtualDiffApply() {},\n    postVirtualDiffApply() {},\n    preDiffApply() {},\n    postDiffApply() {},\n    filterOuterDiff: null,\n    compress: false, // Whether to work with compressed diffs\n    _const: false, // object with strings for every change types to be used in diffs.\n    document: window && window.document ? window.document : false\n}\n\n\nexport class DiffDOM {\n    constructor(options = {}) {\n\n        this.options = options\n        // IE11 doesn't have Object.assign and buble doesn't translate object spreaders\n        // by default, so this is the safest way of doing it currently.\n        Object.entries(DEFAULT_OPTIONS).forEach(([key, value]) => {\n            if (!Object.prototype.hasOwnProperty.call(this.options, key)) {\n                this.options[key] = value\n            }\n        })\n\n        if (!this.options._const) {\n            const varNames = [\"addAttribute\", \"modifyAttribute\", \"removeAttribute\",\n                \"modifyTextElement\", \"relocateGroup\", \"removeElement\", \"addElement\",\n                \"removeTextElement\", \"addTextElement\", \"replaceElement\", \"modifyValue\",\n                \"modifyChecked\", \"modifySelected\", \"modifyComment\", \"action\", \"route\",\n                \"oldValue\", \"newValue\", \"element\", \"group\", \"from\", \"to\", \"name\",\n                \"value\", \"data\", \"attributes\", \"nodeName\", \"childNodes\", \"checked\",\n                \"selected\"\n            ]\n            this.options._const = {}\n            if (this.options.compress) {\n                varNames.forEach((varName, index) => this.options._const[varName] = index)\n            } else {\n                varNames.forEach(varName => this.options._const[varName] = varName)\n            }\n        }\n\n        this.DiffFinder = DiffFinder\n\n    }\n\n    apply(tree, diffs) {\n        return applyDOM(tree, diffs, this.options)\n    }\n\n    undo(tree, diffs) {\n        return undoDOM(tree, diffs, this.options)\n    }\n\n    diff(t1Node, t2Node) {\n        const finder = new this.DiffFinder(t1Node, t2Node, this.options)\n        return finder.init()\n    }\n\n}\n","import {cloneObj} from \"./helpers\"\n\n// ===== Apply a virtual diff =====\n\nfunction getFromVirtualRoute(tree, route) {\n    let node = tree\n    let parentNode\n    let nodeIndex\n\n    route = route.slice()\n    while (route.length > 0) {\n        if (!node.childNodes) {\n            return false\n        }\n        nodeIndex = route.splice(0, 1)[0]\n        parentNode = node\n        node = node.childNodes[nodeIndex]\n    }\n    return {\n        node,\n        parentNode,\n        nodeIndex\n    }\n}\n\nfunction applyVirtualDiff(\n        tree,\n        diff,\n        options // {preDiffApply, postDiffApply, _const}\n    ) {\n    const routeInfo = getFromVirtualRoute(tree, diff[options._const.route])\n    let node = routeInfo.node\n    const parentNode = routeInfo.parentNode\n    const nodeIndex = routeInfo.nodeIndex\n    const newSubsets = []\n\n    // pre-diff hook\n    const info = {\n        diff,\n        node\n    }\n\n    if (options.preDiffApply(info)) {\n        return true\n    }\n\n    let newNode\n    let nodeArray\n    let route\n    let c\n    switch (diff[options._const.action]) {\n        case options._const.addAttribute:\n            if (!node.attributes) {\n                node.attributes = {}\n            }\n\n            node.attributes[diff[options._const.name]] = diff[options._const.value]\n\n            if (diff[options._const.name] === 'checked') {\n                node.checked = true\n            } else if (diff[options._const.name] === 'selected') {\n                node.selected = true\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                node.value = diff[options._const.value]\n            }\n\n            break\n        case options._const.modifyAttribute:\n            node.attributes[diff[options._const.name]] = diff[options._const.newValue]\n            break\n        case options._const.removeAttribute:\n\n            delete node.attributes[diff[options._const.name]]\n\n            if (Object.keys(node.attributes).length === 0) {\n                delete node.attributes\n            }\n\n            if (diff[options._const.name] === 'checked') {\n                node.checked = false\n            } else if (diff[options._const.name] === 'selected') {\n                delete node.selected\n            } else if (node.nodeName === 'INPUT' && diff[options._const.name] === 'value') {\n                delete node.value\n            }\n\n            break\n        case options._const.modifyTextElement:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyValue:\n            node.value = diff[options._const.newValue]\n            break\n        case options._const.modifyComment:\n            node.data = diff[options._const.newValue]\n            break\n        case options._const.modifyChecked:\n            node.checked = diff[options._const.newValue]\n            break\n        case options._const.modifySelected:\n            node.selected = diff[options._const.newValue]\n            break\n        case options._const.replaceElement:\n            newNode = cloneObj(diff[options._const.newValue])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n            parentNode.childNodes[nodeIndex] = newNode\n            break\n        case options._const.relocateGroup:\n            nodeArray = node.childNodes.splice(diff[options._const.from], diff.groupLength).reverse()\n            nodeArray.forEach(movedNode => node.childNodes.splice(diff[options._const.to], 0, movedNode))\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (diff[options._const.from] < diff[options._const.to] && map.oldValue <= diff[options._const.to] && map.oldValue > diff[options._const.from]) {\n                        map.oldValue -= diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[options._const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (diff[options._const.from] > diff[options._const.to] && map.oldValue > diff[options._const.to] && map.oldValue < diff[options._const.from]) {\n                        map.oldValue += diff.groupLength\n                        const splitLength = map.oldValue + map.length - diff[options._const.to]\n                        if (splitLength > 0) {\n                            // new insertion splits map.\n                            newSubsets.push({\n                                oldValue: diff[options._const.to] + diff.groupLength,\n                                newValue: map.newValue + map.length - splitLength,\n                                length: splitLength\n                            })\n                            map.length -= splitLength\n                        }\n                    } else if (map.oldValue === diff[options._const.from]) {\n                        map.oldValue = diff[options._const.to]\n                    }\n                })\n            }\n\n            break\n        case options._const.removeElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            node = getFromVirtualRoute(tree, route).node\n            newNode = cloneObj(diff[options._const.element])\n            newNode.outerDone = true\n            newNode.innerDone = true\n            newNode.valueDone = true\n\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        case options._const.removeTextElement:\n            parentNode.childNodes.splice(nodeIndex, 1)\n            if (parentNode.nodeName === 'TEXTAREA') {\n                delete parentNode.value\n            }\n            if (parentNode.subsets) {\n                parentNode.subsets.forEach(map => {\n                    if (map.oldValue > nodeIndex) {\n                        map.oldValue -= 1\n                    } else if (map.oldValue === nodeIndex) {\n                        map.delete = true\n                    } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                        if (map.oldValue + map.length - 1 === nodeIndex) {\n                            map.length--\n                        } else {\n                            newSubsets.push({\n                                newValue: map.newValue + nodeIndex - map.oldValue,\n                                oldValue: nodeIndex,\n                                length: map.length - nodeIndex + map.oldValue - 1\n                            })\n                            map.length = nodeIndex - map.oldValue\n                        }\n                    }\n                })\n            }\n            node = parentNode\n            break\n        case options._const.addTextElement:\n            route = diff[options._const.route].slice()\n            c = route.splice(route.length - 1, 1)[0]\n            newNode = {}\n            newNode.nodeName = '#text'\n            newNode.data = diff[options._const.value]\n            node = getFromVirtualRoute(tree, route).node\n            if (!node.childNodes) {\n                node.childNodes = []\n            }\n\n            if (c >= node.childNodes.length) {\n                node.childNodes.push(newNode)\n            } else {\n                node.childNodes.splice(c, 0, newNode)\n            }\n            if (node.nodeName === 'TEXTAREA') {\n                node.value = diff[options._const.newValue]\n            }\n            if (node.subsets) {\n                node.subsets.forEach(map => {\n                    if (map.oldValue >= c) {\n                        map.oldValue += 1\n                    }\n                    if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                        const splitLength = map.oldValue + map.length - c\n                        newSubsets.push({\n                            newValue: map.newValue + map.length - splitLength,\n                            oldValue: c + 1,\n                            length: splitLength\n                        })\n                        map.length -= splitLength\n                    }\n                })\n            }\n            break\n        default:\n            console.log('unknown action')\n    }\n\n    if (node.subsets) {\n        node.subsets = node.subsets.filter(map => !map.delete && map.oldValue !== map.newValue)\n        if (newSubsets.length) {\n            node.subsets = node.subsets.concat(newSubsets)\n        }\n    }\n\n    // capture newNode for the callback\n    info.newNode = newNode\n    options.postDiffApply(info)\n\n    return\n}\n\nexport function applyVirtual(tree, diffs, options) {\n    diffs.forEach(diff => {\n        applyVirtualDiff(tree, diff, options)\n    })\n    return true\n}\n","import {Diff, DiffTracker, cloneObj, getGapInformation, isEqual, markSubTrees, removeDone, roughlyEqual} from \"./helpers\"\nimport {applyVirtual} from \"./apply\"\nimport {nodeToObj} from \"./fromDOM\"\nimport {stringToObj} from \"./fromString\"\n\n// ===== Create a diff =====\n\nexport class DiffFinder {\n    constructor(t1Node, t2Node, options) {\n        this.options = options\n        this.t1 = (t1Node instanceof HTMLElement) ? nodeToObj(t1Node, this.options) : (typeof t1Node === 'string') ? stringToObj(t1Node, this.options) : JSON.parse(JSON.stringify(t1Node))\n        this.t2 = (t2Node instanceof HTMLElement) ? nodeToObj(t2Node, this.options) : (typeof t2Node === 'string') ? stringToObj(t2Node, this.options) : JSON.parse(JSON.stringify(t2Node))\n        this.diffcount = 0\n        this.foundAll = false\n        if (this.debug) {\n            this.t1Orig = nodeToObj(t1Node, this.options)\n            this.t2Orig = nodeToObj(t2Node, this.options)\n        }\n\n        this.tracker = new DiffTracker()\n    }\n\n    init() {\n        return this.findDiffs(this.t1, this.t2)\n    }\n\n    findDiffs(t1, t2) {\n        let diffs\n        do {\n            if (this.options.debug) {\n                this.diffcount += 1\n                if (this.diffcount > this.options.diffcap) {\n                    window.diffError = [this.t1Orig, this.t2Orig]\n                    throw new Error(`surpassed diffcap:${JSON.stringify(this.t1Orig)} -> ${JSON.stringify(this.t2Orig)}`)\n                }\n            }\n            diffs = this.findNextDiff(t1, t2, [])\n\n            if (diffs.length === 0) {\n                // Last check if the elements really are the same now.\n                // If not, remove all info about being done and start over.\n                // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                if (!isEqual(t1, t2)) {\n                    if (this.foundAll) {\n                        console.error('Could not find remaining diffs!')\n                    } else {\n                        this.foundAll = true\n                        removeDone(t1)\n                        diffs = this.findNextDiff(t1, t2, [])\n                    }\n                }\n            }\n            if (diffs.length > 0) {\n                this.foundAll = false\n                this.tracker.add(diffs)\n                applyVirtual(t1, diffs, this.options)\n            }\n        } while (diffs.length > 0)\n\n        return this.tracker.list\n    }\n\n    findNextDiff(t1, t2, route) {\n        let diffs\n        let fdiffs\n\n        if (this.options.maxDepth && route.length > this.options.maxDepth) {\n            return []\n        }\n        // outer differences?\n        if (!t1.outerDone) {\n            diffs = this.findOuterDiff(t1, t2, route)\n            if (this.options.filterOuterDiff) {\n                fdiffs = this.options.filterOuterDiff(t1, t2, diffs)\n                if (fdiffs) diffs = fdiffs\n            }\n            if (diffs.length > 0) {\n                t1.outerDone = true\n                return diffs\n            } else {\n                t1.outerDone = true\n            }\n        }\n        // inner differences?\n        if (!t1.innerDone) {\n            diffs = this.findInnerDiff(t1, t2, route)\n            if (diffs.length > 0) {\n                return diffs\n            } else {\n                t1.innerDone = true\n            }\n        }\n\n        if (this.options.valueDiffing && !t1.valueDone) {\n            // value differences?\n            diffs = this.findValueDiff(t1, t2, route)\n\n            if (diffs.length > 0) {\n                t1.valueDone = true\n                return diffs\n            } else {\n                t1.valueDone = true\n            }\n        }\n\n        // no differences\n        return []\n    }\n\n    findOuterDiff(t1, t2, route) {\n        const diffs = []\n        let attr\n        let attr1\n        let attr2\n        let attrLength\n        let pos\n        let i\n        if (t1.nodeName !== t2.nodeName) {\n            if (!route.length) {\n                throw new Error('Top level nodes have to be of the same kind.')\n            }\n            return [new Diff()\n                .setValue(this.options._const.action, this.options._const.replaceElement)\n                .setValue(this.options._const.oldValue, cloneObj(t1))\n                .setValue(this.options._const.newValue, cloneObj(t2))\n                .setValue(this.options._const.route, route)\n            ]\n        }\n        if (route.length && this.options.maxNodeDiffCount < Math.abs((t1.childNodes || []).length - (t2.childNodes || []).length)) {\n            return [new Diff()\n                .setValue(this.options._const.action, this.options._const.replaceElement)\n                .setValue(this.options._const.oldValue, cloneObj(t1))\n                .setValue(this.options._const.newValue, cloneObj(t2))\n                .setValue(this.options._const.route, route)\n            ]\n        }\n\n        if (t1.data !== t2.data) {\n            // Comment or text node.\n            if (t1.nodeName === '#text') {\n                return [new Diff()\n                    .setValue(this.options._const.action, this.options._const.modifyTextElement)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.oldValue, t1.data)\n                    .setValue(this.options._const.newValue, t2.data)\n                ]\n            } else {\n                return [new Diff()\n                    .setValue(this.options._const.action, this.options._const.modifyComment)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.oldValue, t1.data)\n                    .setValue(this.options._const.newValue, t2.data)\n                ]\n            }\n\n        }\n\n        attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : []\n        attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : []\n\n        attrLength = attr1.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr1[i]\n            pos = attr2.indexOf(attr)\n            if (pos === -1) {\n                diffs.push(new Diff()\n                    .setValue(this.options._const.action, this.options._const.removeAttribute)\n                    .setValue(this.options._const.route, route)\n                    .setValue(this.options._const.name, attr)\n                    .setValue(this.options._const.value, t1.attributes[attr])\n                )\n            } else {\n                attr2.splice(pos, 1)\n                if (t1.attributes[attr] !== t2.attributes[attr]) {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.modifyAttribute)\n                        .setValue(this.options._const.route, route)\n                        .setValue(this.options._const.name, attr)\n                        .setValue(this.options._const.oldValue, t1.attributes[attr])\n                        .setValue(this.options._const.newValue, t2.attributes[attr])\n                    )\n                }\n            }\n        }\n\n        attrLength = attr2.length\n        for (i = 0; i < attrLength; i++) {\n            attr = attr2[i]\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.addAttribute)\n                .setValue(this.options._const.route, route)\n                .setValue(this.options._const.name, attr)\n                .setValue(this.options._const.value, t2.attributes[attr])\n            )\n        }\n\n        return diffs\n    }\n\n    findInnerDiff(t1, t2, route) {\n        const t1ChildNodes = t1.childNodes ? t1.childNodes.slice() : []\n        const t2ChildNodes = t2.childNodes ? t2.childNodes.slice() : []\n        const last = Math.max(t1ChildNodes.length, t2ChildNodes.length)\n        let childNodesLengthDifference = Math.abs(t1ChildNodes.length - t2ChildNodes.length)\n        let diffs = []\n        let index = 0\n        if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n            const subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ? markSubTrees(t1, t2) : []\n\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(t1, t2, subtrees, route)\n                if (diffs.length > 0) {\n                    return diffs\n                }\n            }\n        }\n\n\n        /* 0 or 1 groups of similar child nodes have been found\n         * for t1 and t2. 1 If there is 1, it could be a sign that the\n         * contents are the same. When the number of groups is below 2,\n         * t1 and t2 are made to have the same length and each of the\n         * pairs of child nodes are diffed.\n         */\n\n        for (let i = 0; i < last; i += 1) {\n            const e1 = t1ChildNodes[i]\n            const e2 = t2ChildNodes[i]\n\n            if (childNodesLengthDifference) {\n                /* t1 and t2 have different amounts of childNodes. Add\n                 * and remove as necessary to obtain the same length */\n                if (e1 && !e2) {\n                    if (e1.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.removeTextElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.value, e1.data)\n                        )\n                        index -= 1\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.removeElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.element, cloneObj(e1))\n                        )\n                        index -= 1\n                    }\n\n                } else if (e2 && !e1) {\n                    if (e2.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.addTextElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.value, e2.data)\n                        )\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(this.options._const.action, this.options._const.addElement)\n                            .setValue(this.options._const.route, route.concat(index))\n                            .setValue(this.options._const.element, cloneObj(e2))\n                        )\n                    }\n                }\n            }\n            /* We are now guaranteed that childNodes e1 and e2 exist,\n             * and that they can be diffed.\n             */\n            /* Diffs in child nodes should not affect the parent node,\n             * so we let these diffs be submitted together with other\n             * diffs.\n             */\n\n            if (e1 && e2) {\n                if (!this.options.maxChildCount || last < this.options.maxChildCount) {\n                    diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)))\n                } else if (!isEqual(e1, e2)) {\n                    if (t1ChildNodes.length > t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(this.options._const.action, this.options._const.removeElement)\n                                .setValue(this.options._const.element, cloneObj(e1))\n                                .setValue(this.options._const.route, route.concat(index))\n                        ])\n                        t1ChildNodes.splice(i, 1)\n                        index -= 1\n                        childNodesLengthDifference -= 1\n                    } else if (t1ChildNodes.length < t2ChildNodes.length) {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(this.options._const.action, this.options._const.addElement)\n                                .setValue(this.options._const.element, cloneObj(e2))\n                                .setValue(this.options._const.route, route.concat(index))\n                        ])\n                        t1ChildNodes.splice(i, 0, {})\n                        childNodesLengthDifference -= 1\n                    } else {\n                        diffs = diffs.concat([\n                            new Diff()\n                                .setValue(this.options._const.action, this.options._const.replaceElement)\n                                .setValue(this.options._const.oldValue, cloneObj(e1))\n                                .setValue(this.options._const.newValue, cloneObj(e2))\n                                .setValue(this.options._const.route, route.concat(index))\n                        ])\n                    }\n\n                }\n\n            }\n            index += 1\n\n        }\n        t1.innerDone = true\n        return diffs\n    }\n\n    attemptGroupRelocation(t1, t2, subtrees, route) {\n        /* Either t1.childNodes and t2.childNodes have the same length, or\n         * there are at least two groups of similar elements can be found.\n         * attempts are made at equalizing t1 with t2. First all initial\n         * elements with no group affiliation (gaps=true) are removed (if\n         * only in t1) or added (if only in t2). Then the creation of a group\n         * relocation diff is attempted.\n         */\n        const gapInformation = getGapInformation(t1, t2, subtrees)\n        const gaps1 = gapInformation.gaps1\n        const gaps2 = gapInformation.gaps2\n        let shortest = Math.min(gaps1.length, gaps2.length)\n        let destinationDifferent\n        let toGroup\n        let group\n        let node\n        let similarNode\n        let testI\n        const diffs = []\n\n\n        for (let index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n            if (gaps1[index2] === true) {\n                node = t1.childNodes[index1]\n                if (node.nodeName === '#text') {\n                    if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\n                        testI = index1\n                        while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                            testI += 1\n                            if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                similarNode = true\n                                break\n                            }\n                        }\n                        if (!similarNode) {\n                            diffs.push(new Diff()\n                                .setValue(this.options._const.action, this.options._const.modifyTextElement)\n                                .setValue(this.options._const.route, route.concat(index2))\n                                .setValue(this.options._const.oldValue, node.data)\n                                .setValue(this.options._const.newValue, t2.childNodes[index2].data)\n                            )\n                            return diffs\n                        }\n                    }\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.removeTextElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.removeElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 1)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index2 -= 1\n                }\n\n            } else if (gaps2[index2] === true) {\n                node = t2.childNodes[index2]\n                if (node.nodeName === '#text') {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.addTextElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.value, node.data)\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                } else {\n                    diffs.push(new Diff()\n                        .setValue(this.options._const.action, this.options._const.addElement)\n                        .setValue(this.options._const.route, route.concat(index2))\n                        .setValue(this.options._const.element, cloneObj(node))\n                    )\n                    gaps1.splice(index2, 0, true)\n                    shortest = Math.min(gaps1.length, gaps2.length)\n                    index1 -= 1\n                }\n\n            } else if (gaps1[index2] !== gaps2[index2]) {\n                if (diffs.length > 0) {\n                    return diffs\n                }\n                // group relocation\n                group = subtrees[gaps1[index2]]\n                toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length))\n                if (toGroup !== group.oldValue) {\n                    // Check whether destination nodes are different than originating ones.\n                    destinationDifferent = false\n                    for (let j = 0; j < group.length; j += 1) {\n                        if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                            destinationDifferent = true\n                        }\n                    }\n                    if (destinationDifferent) {\n                        return [new Diff()\n                            .setValue(this.options._const.action, this.options._const.relocateGroup)\n                            .setValue('groupLength', group.length)\n                            .setValue(this.options._const.from, group.oldValue)\n                            .setValue(this.options._const.to, toGroup)\n                            .setValue(this.options._const.route, route)\n                        ]\n                    }\n                }\n            }\n        }\n        return diffs\n    }\n\n    findValueDiff(t1, t2, route) {\n        // Differences of value. Only useful if the value/selection/checked value\n        // differs from what is represented in the DOM. For example in the case\n        // of filled out forms, etc.\n        const diffs = []\n\n        if (t1.selected !== t2.selected) {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifySelected)\n                .setValue(this.options._const.oldValue, t1.selected)\n                .setValue(this.options._const.newValue, t2.selected)\n                .setValue(this.options._const.route, route)\n            )\n        }\n\n        if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifyValue)\n                .setValue(this.options._const.oldValue, t1.value || \"\")\n                .setValue(this.options._const.newValue, t2.value || \"\")\n                .setValue(this.options._const.route, route)\n            )\n        }\n        if (t1.checked !== t2.checked) {\n            diffs.push(new Diff()\n                .setValue(this.options._const.action, this.options._const.modifyChecked)\n                .setValue(this.options._const.oldValue, t1.checked)\n                .setValue(this.options._const.newValue, t2.checked)\n                .setValue(this.options._const.route, route)\n            )\n        }\n\n        return diffs\n    }\n\n}\n","export function nodeToObj(aNode, options = {}) {\n    const objNode = {}\n    objNode.nodeName = aNode.nodeName\n    if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\n        objNode.data = aNode.data\n    } else {\n        if (aNode.attributes && aNode.attributes.length > 0) {\n            objNode.attributes = {}\n            const nodeArray = Array.prototype.slice.call(aNode.attributes)\n            nodeArray.forEach(attribute => objNode.attributes[attribute.name] = attribute.value)\n        }\n        if (objNode.nodeName === 'TEXTAREA') {\n            objNode.value = aNode.value\n        } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n            objNode.childNodes = []\n            const nodeArray = Array.prototype.slice.call(aNode.childNodes)\n            nodeArray.forEach(childNode => objNode.childNodes.push(nodeToObj(childNode, options)))\n        }\n        if (options.valueDiffing) {\n            if (aNode.checked !== undefined && aNode.type && ['radio', 'checkbox'].includes(aNode.type.toLowerCase())) {\n                objNode.checked = aNode.checked\n            } else if (aNode.value !== undefined) {\n                objNode.value = aNode.value\n            }\n            if (aNode.selected !== undefined) {\n                objNode.selected = aNode.selected\n            }\n        }\n    }\n    return objNode\n}\n","// from html-parse-stringify (MIT)\n\nconst tagRE = /<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>/g\n// re-used obj for quick lookups of components\nconst empty = Object.create ? Object.create(null) : {}\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\n\nfunction unescape(string) {\n    return string.replace(/&lt;/g, '<').replace(/&gt;/g, '>')\n.replace(/&amp;/g, '&')\n}\n\n// create optimized lookup object for\n// void elements as listed here:\n// http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\nconst lookup = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuItem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n}\n\n\nfunction parseTag(tag) {\n    const res = {\n        nodeName: '',\n        attributes: {}\n    }\n\n    let tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n    if (tagMatch) {\n        res.nodeName = tagMatch[1].toUpperCase()\n        if (lookup[tagMatch[1].toLowerCase()] || tag.charAt(tag.length - 2) === '/') res.voidElement = true\n\n    }\n\n    let reg = new RegExp(attrRE)\n    let result = null\n    let done = false\n    while (!done) {\n        result = reg.exec(tag)\n\n        if (result === null) {\n            done = true\n        } else if (result[0].trim()) {\n            if (result[1]) {\n                let attr = result[1].trim()\n                let arr = [attr, \"\"]\n\n                if (attr.indexOf(\"=\") > -1) arr = attr.split(\"=\")\n\n                res.attributes[arr[0]] = arr[1]\n                reg.lastIndex--\n            } else if (result[2]) res.attributes[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n        }\n    }\n\n    return res\n}\n\nfunction parse(\n    html,\n    options = {components: empty}\n) {\n    const result = []\n    let current\n    let level = -1\n    const arr = []\n    const byTag = {}\n    let inComponent = false\n\n    html.replace(tagRE, (tag, index) => {\n        if (inComponent) {\n            if (tag !== (`</${current.nodeName}>`)) {\n                return\n            } else {\n                inComponent = false\n            }\n        }\n        const isOpen = tag.charAt(1) !== '/'\n        const start = index + tag.length\n        const nextChar = html.charAt(start)\n        let parent\n\n        if (isOpen) {\n            level++\n\n            current = parseTag(tag)\n            if (current.type === 'tag' && options.components[current.nodeName]) {\n                current.type = 'component'\n                inComponent = true\n            }\n\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n                if (!current.childNodes) {\n                    current.childNodes = []\n                }\n                current.childNodes.push({\n                    nodeName: '#text',\n                    data: unescape(html.slice(start, html.indexOf('<', start)))\n                })\n            }\n\n            byTag[current.tagName] = current\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current)\n            }\n\n            parent = arr[level - 1]\n\n            if (parent) {\n                if (!parent.childNodes) {\n                    parent.childNodes = []\n                }\n                parent.childNodes.push(current)\n            }\n\n            arr[level] = current\n        }\n\n        if (!isOpen || current.voidElement) {\n            level--\n            if (!inComponent && nextChar !== '<' && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].childNodes || []\n\n                // calculate correct end of the data slice in case there's\n                // no tag after the text node.\n                const end = html.indexOf('<', start)\n                const data = unescape(html.slice(start, end === -1 ? undefined : end))\n                parent.push({\n                    nodeName: '#text',\n                    data\n                })\n            }\n        }\n    })\n\n    return result[0]\n}\n\nfunction cleanObj(obj) {\n    delete obj.voidElement\n    if (obj.childNodes) {\n        obj.childNodes.forEach(child => cleanObj(child))\n    }\n    return obj\n}\n\nexport function stringToObj(string) {\n    return cleanObj(parse(string))\n}\n","export class Diff {\n    constructor(options = {}) {\n        Object.entries(options).forEach(([key, value]) => this[key] = value)\n    }\n\n    toString() {\n        return JSON.stringify(this)\n    }\n\n    setValue(aKey, aValue) {\n        this[aKey] = aValue\n        return this\n    }\n}\n\nfunction elementDescriptors(el) {\n    const output = []\n    if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n        output.push(el.nodeName)\n        if (el.attributes) {\n            if (el.attributes['class']) {\n                output.push(`${el.nodeName}.${el.attributes['class'].replace(/ /g, '.')}`)\n            }\n            if (el.attributes.id) {\n                output.push(`${el.nodeName}#${el.attributes.id}`)\n            }\n        }\n\n    }\n    return output\n}\n\nfunction findUniqueDescriptors(li) {\n    const uniqueDescriptors = {}\n    const duplicateDescriptors = {}\n\n    li.forEach(node => {\n        elementDescriptors(node).forEach(descriptor => {\n            const inUnique = descriptor in uniqueDescriptors\n            const inDupes = descriptor in duplicateDescriptors\n            if (!inUnique && !inDupes) {\n                uniqueDescriptors[descriptor] = true\n            } else if (inUnique) {\n                delete uniqueDescriptors[descriptor]\n                duplicateDescriptors[descriptor] = true\n            }\n        })\n    })\n\n    return uniqueDescriptors\n}\n\nfunction uniqueInBoth(l1, l2) {\n    const l1Unique = findUniqueDescriptors(l1)\n    const l2Unique = findUniqueDescriptors(l2)\n    const inBoth = {}\n\n    Object.keys(l1Unique).forEach(key => {\n        if (l2Unique[key]) {\n            inBoth[key] = true\n        }\n    })\n\n    return inBoth\n}\n\nexport function removeDone(tree) {\n    delete tree.outerDone\n    delete tree.innerDone\n    delete tree.valueDone\n    if (tree.childNodes) {\n        return tree.childNodes.every(removeDone)\n    } else {\n        return true\n    }\n}\n\nexport function isEqual(e1, e2) {\n    if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(element => {\n            if (e1[element] !== e2[element]) {\n                return false\n            }\n            return true\n        })) {\n        return false\n    }\n\n    if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n        return false\n    }\n\n    if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n        return false\n    }\n    if (e1.attributes) {\n        const e1Attributes = Object.keys(e1.attributes)\n        const e2Attributes = Object.keys(e2.attributes)\n\n        if (e1Attributes.length !== e2Attributes.length) {\n            return false\n        }\n        if (!e1Attributes.every(attribute => {\n                if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                    return false\n                }\n                return true\n            })) {\n            return false\n        }\n    }\n    if (e1.childNodes) {\n        if (e1.childNodes.length !== e2.childNodes.length) {\n            return false\n        }\n        if (!e1.childNodes.every((childNode, index) => isEqual(childNode, e2.childNodes[index]))) {\n\n            return false\n        }\n\n    }\n\n    return true\n}\n\n\nexport function roughlyEqual(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n\n    if (!e1 || !e2) {\n        return false\n    }\n\n    if (e1.nodeName !== e2.nodeName) {\n        return false\n    }\n\n    if (e1.nodeName === '#text') {\n        // Note that we initially don't care what the text content of a node is,\n        // the mere fact that it's the same tag and \"has text\" means it's roughly\n        // equal, and then we can find out the true text difference later.\n        return preventRecursion ? true : e1.data === e2.data\n    }\n\n\n    if (e1.nodeName in uniqueDescriptors) {\n        return true\n    }\n\n    if (e1.attributes && e2.attributes) {\n\n        if (e1.attributes.id) {\n            if (e1.attributes.id !== e2.attributes.id) {\n                return false\n            } else {\n                const idDescriptor = `${e1.nodeName}#${e1.attributes.id}`\n                if (idDescriptor in uniqueDescriptors) {\n                    return true\n                }\n            }\n        }\n        if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n            const classDescriptor = `${e1.nodeName}.${e1.attributes['class'].replace(/ /g, '.')}`\n            if (classDescriptor in uniqueDescriptors) {\n                return true\n            }\n        }\n    }\n\n    if (sameSiblings) {\n        return true\n    }\n\n    const nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : []\n    const nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : []\n\n    if (nodeList1.length !== nodeList2.length) {\n        return false\n    }\n\n    if (preventRecursion) {\n        return nodeList1.every((element, index) => element.nodeName === nodeList2[index].nodeName)\n    } else {\n        // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n        // was not set, we must explicitly force it to true for child iterations.\n        const childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2)\n        return nodeList1.every((element, index) => roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true))\n    }\n}\n\n\nexport function cloneObj(obj) { //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n    return JSON.parse(JSON.stringify(obj))\n}\n/**\n * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n */\nfunction findCommonSubsets(c1, c2, marked1, marked2) {\n    let lcsSize = 0\n    let index = []\n    const c1Length = c1.length\n    const c2Length = c2.length\n\n    const // set up the matching table\n        matches = Array(...new Array(c1Length + 1)).map(() => [])\n\n    const uniqueDescriptors = uniqueInBoth(c1, c2)\n\n    let // If all of the elements are the same tag, id and class, then we can\n        // consider them roughly the same even if they have a different number of\n        // children. This will reduce removing and re-adding similar elements.\n        subsetsSame = c1Length === c2Length\n\n    if (subsetsSame) {\n\n        c1.some((element, i) => {\n            const c1Desc = elementDescriptors(element)\n            const c2Desc = elementDescriptors(c2[i])\n            if (c1Desc.length !== c2Desc.length) {\n                subsetsSame = false\n                return true\n            }\n            c1Desc.some((description, i) => {\n                if (description !== c2Desc[i]) {\n                    subsetsSame = false\n                    return true\n                }\n            })\n            if (!subsetsSame) {\n                return true\n            }\n        })\n    }\n\n    // fill the matches with distance values\n    for (let c1Index = 0; c1Index < c1Length; c1Index++) {\n        const c1Element = c1[c1Index]\n        for (let c2Index = 0; c2Index < c2Length; c2Index++) {\n            const c2Element = c2[c2Index]\n            if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1)\n                if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                    lcsSize = matches[c1Index + 1][c2Index + 1]\n                    index = [c1Index + 1, c2Index + 1]\n                }\n            } else {\n                matches[c1Index + 1][c2Index + 1] = 0\n            }\n        }\n    }\n\n    if (lcsSize === 0) {\n        return false\n    }\n\n    return {\n        oldValue: index[0] - lcsSize,\n        newValue: index[1] - lcsSize,\n        length: lcsSize\n    }\n}\n\n/**\n * This should really be a predefined function in Array...\n */\nfunction makeArray(n, v) {\n    return Array(...new Array(n)).map(() => v)\n}\n\n/**\n * Generate arrays that indicate which node belongs to which subset,\n * or whether it's actually an orphan node, existing in only one\n * of the two trees, rather than somewhere in both.\n *\n * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n * The second longest is \"<img>\" (length 1), so it will be group 1.\n * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n *\n * If an element is not part of any group, it will stay being 'true', which\n * is the initial value. For example:\n * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n *\n * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n * therefore be marked by \"true\". The remaining parts are parts of the\n * groups 0 and 1:\n * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n *\n */\nexport function getGapInformation(t1, t2, stable) {\n    const gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : []\n    const gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : []\n    let group = 0\n\n    // give elements from the same subset the same group number\n    stable.forEach(subset => {\n        const endOld = subset.oldValue + subset.length\n        const endNew = subset.newValue + subset.length\n\n        for (let j = subset.oldValue; j < endOld; j += 1) {\n            gaps1[j] = group\n        }\n        for (let j = subset.newValue; j < endNew; j += 1) {\n            gaps2[j] = group\n        }\n        group += 1\n    })\n\n    return {\n        gaps1,\n        gaps2\n    }\n}\n\n/**\n * Find all matching subsets, based on immediate child differences only.\n */\nexport function markSubTrees(oldTree, newTree) {\n    // note: the child lists are views, and so update as we update old/newTree\n    const oldChildren = oldTree.childNodes ? oldTree.childNodes : []\n\n    const newChildren = newTree.childNodes ? newTree.childNodes : []\n    const marked1 = makeArray(oldChildren.length, false)\n    const marked2 = makeArray(newChildren.length, false)\n    const subsets = []\n    let subset = true\n\n    const returnIndex = function() {\n        return arguments[1]\n    }\n\n    const markBoth = i => {\n        marked1[subset.oldValue + i] = true\n        marked2[subset.newValue + i] = true\n    }\n\n    while (subset) {\n        subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2)\n        if (subset) {\n            subsets.push(subset)\n            const subsetArray = Array(...new Array(subset.length)).map(returnIndex)\n            subsetArray.forEach(item => markBoth(item))\n        }\n    }\n\n    oldTree.subsets = subsets\n    oldTree.subsetsAge = 100\n    return subsets\n}\n\nexport class DiffTracker {\n    constructor() {\n        this.list = []\n    }\n\n    add(diffs) {\n        this.list.push(...diffs)\n    }\n    forEach(fn) {\n        this.list.forEach(li => fn(li))\n    }\n\n}\n","export {DiffFinder} from \"./diff\"\nexport {nodeToObj} from \"./fromDOM\"\nexport {stringToObj} from \"./fromString\"\n","export {DiffDOM, nodeToObj, stringToObj} from \"./diffDOM/index\"\nexport {TraceLogger} from \"./TraceLogger\"\n","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","assert.notEqual = notEqual\nassert.notOk = notOk\nassert.equal = equal\nassert.ok = assert\n\nmodule.exports = assert\n\nfunction equal (a, b, m) {\n  assert(a == b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notEqual (a, b, m) {\n  assert(a != b, m) // eslint-disable-line eqeqeq\n}\n\nfunction notOk (t, m) {\n  assert(!t, m)\n}\n\nfunction assert (t, m) {\n  if (!t) throw new Error(m || 'AssertionError')\n}\n","var assert = require('nanoassert')\nvar morph = require('./lib/morph')\n\nvar TEXT_NODE = 3\n// var DEBUG = false\n\nmodule.exports = nanomorph\n\n// Morph one tree into another tree\n//\n// no parent\n//   -> same: diff and walk children\n//   -> not same: replace and return\n// old node doesn't exist\n//   -> insert new node\n// new node doesn't exist\n//   -> delete old node\n// nodes are not the same\n//   -> diff nodes and apply patch to old node\n// nodes are the same\n//   -> walk all child nodes and append to old node\nfunction nanomorph (oldTree, newTree, options) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'nanomorph\\nold\\n  %s\\nnew\\n  %s',\n  //   oldTree && oldTree.outerHTML,\n  //   newTree && newTree.outerHTML\n  // )\n  // }\n  assert.equal(typeof oldTree, 'object', 'nanomorph: oldTree should be an object')\n  assert.equal(typeof newTree, 'object', 'nanomorph: newTree should be an object')\n\n  if (options && options.childrenOnly) {\n    updateChildren(newTree, oldTree)\n    return oldTree\n  }\n\n  assert.notEqual(\n    newTree.nodeType,\n    11,\n    'nanomorph: newTree should have one root node (which is not a DocumentFragment)'\n  )\n\n  return walk(newTree, oldTree)\n}\n\n// Walk and morph a dom tree\nfunction walk (newNode, oldNode) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'walk\\nold\\n  %s\\nnew\\n  %s',\n  //   oldNode && oldNode.outerHTML,\n  //   newNode && newNode.outerHTML\n  // )\n  // }\n  if (!oldNode) {\n    return newNode\n  } else if (!newNode) {\n    return null\n  } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {\n    return oldNode\n  } else if (newNode.tagName !== oldNode.tagName || getComponentId(newNode) !== getComponentId(oldNode)) {\n    return newNode\n  } else {\n    morph(newNode, oldNode)\n    updateChildren(newNode, oldNode)\n    return oldNode\n  }\n}\n\nfunction getComponentId (node) {\n  return node.dataset ? node.dataset.nanomorphComponentId : undefined\n}\n\n// Update the children of elements\n// (obj, obj) -> null\nfunction updateChildren (newNode, oldNode) {\n  // if (DEBUG) {\n  //   console.log(\n  //   'updateChildren\\nold\\n  %s\\nnew\\n  %s',\n  //   oldNode && oldNode.outerHTML,\n  //   newNode && newNode.outerHTML\n  // )\n  // }\n  var oldChild, newChild, morphed, oldMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop\n  var offset = 0\n\n  for (var i = 0; ; i++) {\n    oldChild = oldNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n    // if (DEBUG) {\n    //   console.log(\n    //   '===\\n- old\\n  %s\\n- new\\n  %s',\n    //   oldChild && oldChild.outerHTML,\n    //   newChild && newChild.outerHTML\n    // )\n    // }\n    // Both nodes are empty, do nothing\n    if (!oldChild && !newChild) {\n      break\n\n    // There is no new child, remove old\n    } else if (!newChild) {\n      oldNode.removeChild(oldChild)\n      i--\n\n    // There is no old child, add new\n    } else if (!oldChild) {\n      oldNode.appendChild(newChild)\n      offset++\n\n    // Both nodes are the same, morph\n    } else if (same(newChild, oldChild)) {\n      morphed = walk(newChild, oldChild)\n      if (morphed !== oldChild) {\n        oldNode.replaceChild(morphed, oldChild)\n        offset++\n      }\n\n    // Both nodes do not share an ID or a placeholder, try reorder\n    } else {\n      oldMatch = null\n\n      // Try and find a similar node somewhere in the tree\n      for (var j = i; j < oldNode.childNodes.length; j++) {\n        if (same(oldNode.childNodes[j], newChild)) {\n          oldMatch = oldNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list\n      if (oldMatch) {\n        morphed = walk(newChild, oldMatch)\n        if (morphed !== oldMatch) offset++\n        oldNode.insertBefore(morphed, oldChild)\n\n      // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !oldChild.id) {\n        morphed = walk(newChild, oldChild)\n        if (morphed !== oldChild) {\n          oldNode.replaceChild(morphed, oldChild)\n          offset++\n        }\n\n      // Insert the node at the index if we couldn't morph or find a matching node\n      } else {\n        oldNode.insertBefore(newChild, oldChild)\n        offset++\n      }\n    }\n  }\n}\n\nfunction same (a, b) {\n  if (a.id) return a.id === b.id\n  if (a.isSameNode) return a.isSameNode(b)\n  if (a.tagName !== b.tagName) return false\n  if (a.type === TEXT_NODE) return a.nodeValue === b.nodeValue\n  return false\n}\n","module.exports = [\n  // attribute events (can be set with attributes)\n  'onclick',\n  'ondblclick',\n  'onmousedown',\n  'onmouseup',\n  'onmouseover',\n  'onmousemove',\n  'onmouseout',\n  'onmouseenter',\n  'onmouseleave',\n  'ontouchcancel',\n  'ontouchend',\n  'ontouchmove',\n  'ontouchstart',\n  'ondragstart',\n  'ondrag',\n  'ondragenter',\n  'ondragleave',\n  'ondragover',\n  'ondrop',\n  'ondragend',\n  'onkeydown',\n  'onkeypress',\n  'onkeyup',\n  'onunload',\n  'onabort',\n  'onerror',\n  'onresize',\n  'onscroll',\n  'onselect',\n  'onchange',\n  'onsubmit',\n  'onreset',\n  'onfocus',\n  'onblur',\n  'oninput',\n  // other common events\n  'oncontextmenu',\n  'onfocusin',\n  'onfocusout'\n]\n","var events = require('./events')\nvar eventsLength = events.length\n\nvar ELEMENT_NODE = 1\nvar TEXT_NODE = 3\nvar COMMENT_NODE = 8\n\nmodule.exports = morph\n\n// diff elements and apply the resulting patch to the old node\n// (obj, obj) -> null\nfunction morph (newNode, oldNode) {\n  var nodeType = newNode.nodeType\n  var nodeName = newNode.nodeName\n\n  if (nodeType === ELEMENT_NODE) {\n    copyAttrs(newNode, oldNode)\n  }\n\n  if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {\n    if (oldNode.nodeValue !== newNode.nodeValue) {\n      oldNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') updateInput(newNode, oldNode)\n  else if (nodeName === 'OPTION') updateOption(newNode, oldNode)\n  else if (nodeName === 'TEXTAREA') updateTextarea(newNode, oldNode)\n\n  copyEvents(newNode, oldNode)\n}\n\nfunction copyAttrs (newNode, oldNode) {\n  var oldAttrs = oldNode.attributes\n  var newAttrs = newNode.attributes\n  var attrNamespaceURI = null\n  var attrValue = null\n  var fromValue = null\n  var attrName = null\n  var attr = null\n\n  for (var i = newAttrs.length - 1; i >= 0; --i) {\n    attr = newAttrs[i]\n    attrName = attr.name\n    attrNamespaceURI = attr.namespaceURI\n    attrValue = attr.value\n    if (attrNamespaceURI) {\n      attrName = attr.localName || attrName\n      fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName)\n      if (fromValue !== attrValue) {\n        oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue)\n      }\n    } else {\n      if (!oldNode.hasAttribute(attrName)) {\n        oldNode.setAttribute(attrName, attrValue)\n      } else {\n        fromValue = oldNode.getAttribute(attrName)\n        if (fromValue !== attrValue) {\n          // apparently values are always cast to strings, ah well\n          if (attrValue === 'null' || attrValue === 'undefined') {\n            oldNode.removeAttribute(attrName)\n          } else {\n            oldNode.setAttribute(attrName, attrValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (var j = oldAttrs.length - 1; j >= 0; --j) {\n    attr = oldAttrs[j]\n    if (attr.specified !== false) {\n      attrName = attr.name\n      attrNamespaceURI = attr.namespaceURI\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName\n        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          oldNode.removeAttributeNS(attrNamespaceURI, attrName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attrName)) {\n          oldNode.removeAttribute(attrName)\n        }\n      }\n    }\n  }\n}\n\nfunction copyEvents (newNode, oldNode) {\n  for (var i = 0; i < eventsLength; i++) {\n    var ev = events[i]\n    if (newNode[ev]) {           // if new element has a whitelisted attribute\n      oldNode[ev] = newNode[ev]  // update existing element\n    } else if (oldNode[ev]) {    // if existing element has it and new one doesnt\n      oldNode[ev] = undefined    // remove it from existing element\n    }\n  }\n}\n\nfunction updateOption (newNode, oldNode) {\n  updateAttribute(newNode, oldNode, 'selected')\n}\n\n// The \"value\" attribute is special for the <input> element since it sets the\n// initial value. Changing the \"value\" attribute without changing the \"value\"\n// property will have no effect since it is only used to the set the initial\n// value. Similar for the \"checked\" attribute, and \"disabled\".\nfunction updateInput (newNode, oldNode) {\n  var newValue = newNode.value\n  var oldValue = oldNode.value\n\n  updateAttribute(newNode, oldNode, 'checked')\n  updateAttribute(newNode, oldNode, 'disabled')\n\n  if (newValue !== oldValue) {\n    oldNode.setAttribute('value', newValue)\n    oldNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    oldNode.value = ''\n    oldNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    oldNode.removeAttribute('value')\n  } else if (oldNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    oldNode.value = newValue\n  }\n}\n\nfunction updateTextarea (newNode, oldNode) {\n  var newValue = newNode.value\n  if (newValue !== oldNode.value) {\n    oldNode.value = newValue\n  }\n\n  if (oldNode.firstChild && oldNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and vise versa. This ignores an empty update.\n    if (newValue === '' && oldNode.firstChild.nodeValue === oldNode.placeholder) {\n      return\n    }\n\n    oldNode.firstChild.nodeValue = newValue\n  }\n}\n\nfunction updateAttribute (newNode, oldNode, name) {\n  if (newNode[name] !== oldNode[name]) {\n    oldNode[name] = newNode[name]\n    if (newNode[name]) {\n      oldNode.setAttribute(name, '')\n    } else {\n      oldNode.removeAttribute(name)\n    }\n  }\n}\n","import { vnode } from './vnode';\nimport * as is from './is';\nfunction addNS(data, children, sel) {\n    data.ns = 'http://www.w3.org/2000/svg';\n    if (sel !== 'foreignObject' && children !== undefined) {\n        for (var i = 0; i < children.length; ++i) {\n            var childData = children[i].data;\n            if (childData !== undefined) {\n                addNS(childData, children[i].children, children[i].sel);\n            }\n        }\n    }\n}\nexport function h(sel, b, c) {\n    var data = {}, children, text, i;\n    if (c !== undefined) {\n        data = b;\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c;\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b;\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {\n        addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, text, undefined);\n}\n;\nexport default h;\n//# sourceMappingURL=h.js.map","function createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexport var htmlDomApi = {\n    createElement: createElement,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    getTextContent: getTextContent,\n    isElement: isElement,\n    isText: isText,\n    isComment: isComment,\n};\nexport default htmlDomApi;\n//# sourceMappingURL=htmldomapi.js.map","export var array = Array.isArray;\nexport function primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\n//# sourceMappingURL=is.js.map","import vnode from './vnode';\nimport * as is from './is';\nimport htmlDomApi from './htmldomapi';\nfunction isUndef(s) { return s === undefined; }\nfunction isDef(s) { return s !== undefined; }\nvar emptyNode = vnode('', {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVnode(vnode) {\n    return vnode.sel !== undefined;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, map = {}, key, ch;\n    for (i = beginIdx; i <= endIdx; ++i) {\n        ch = children[i];\n        if (ch != null) {\n            key = ch.key;\n            if (key !== undefined)\n                map[key] = i;\n        }\n    }\n    return map;\n}\nvar hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\nexport { h } from './h';\nexport { thunk } from './thunk';\nexport function init(modules, domApi) {\n    var i, j, cbs = {};\n    var api = domApi !== undefined ? domApi : htmlDomApi;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            var hook = modules[j][hooks[i]];\n            if (hook !== undefined) {\n                cbs[hooks[i]].push(hook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        var id = elm.id ? '#' + elm.id : '';\n        var c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                var parent_1 = api.parentNode(childElm);\n                api.removeChild(parent_1, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var i, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.init)) {\n                i(vnode);\n                data = vnode.data;\n            }\n        }\n        var children = vnode.children, sel = vnode.sel;\n        if (sel === '!') {\n            if (isUndef(vnode.text)) {\n                vnode.text = '';\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            var hashIdx = sel.indexOf('#');\n            var dotIdx = sel.indexOf('.', hashIdx);\n            var hash = hashIdx > 0 ? hashIdx : sel.length;\n            var dot = dotIdx > 0 ? dotIdx : sel.length;\n            var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            var elm = vnode.elm = isDef(data) && isDef(i = data.ns) ? api.createElementNS(i, tag)\n                : api.createElement(tag);\n            if (hash < dot)\n                elm.setAttribute('id', sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    var ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (is.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            i = vnode.data.hook; // Reuse variable\n            if (isDef(i)) {\n                if (i.create)\n                    i.create(emptyNode, vnode);\n                if (i.insert)\n                    insertedVnodeQueue.push(vnode);\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var i, j, data = vnode.data;\n        if (data !== undefined) {\n            if (isDef(i = data.hook) && isDef(i = i.destroy))\n                i(vnode);\n            for (i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (j = 0; j < vnode.children.length; ++j) {\n                    i = vnode.children[j];\n                    if (i != null && typeof i !== \"string\") {\n                        invokeDestroyHook(i);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            var i_1 = void 0, listeners = void 0, rm = void 0, ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (i_1 = 0; i_1 < cbs.remove.length; ++i_1)\n                        cbs.remove[i_1](ch, rm);\n                    if (isDef(i_1 = ch.data) && isDef(i_1 = i_1.hook) && isDef(i_1 = i_1.remove)) {\n                        i_1(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else { // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        var oldStartIdx = 0, newStartIdx = 0;\n        var oldEndIdx = oldCh.length - 1;\n        var oldStartVnode = oldCh[0];\n        var oldEndVnode = oldCh[oldEndIdx];\n        var newEndIdx = newCh.length - 1;\n        var newStartVnode = newCh[0];\n        var newEndVnode = newCh[newEndIdx];\n        var oldKeyToIdx;\n        var idxInOld;\n        var elmToMove;\n        var before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) { // New element\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n            if (oldStartIdx > oldEndIdx) {\n                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n            }\n            else {\n                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n            }\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var i, hook;\n        if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {\n            i(oldVnode, vnode);\n        }\n        var elm = vnode.elm = oldVnode.elm;\n        var oldCh = oldVnode.children;\n        var ch = vnode.children;\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined) {\n            for (i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            i = vnode.data.hook;\n            if (isDef(i) && isDef(i = i.update))\n                i(oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        if (isDef(hook) && isDef(i = hook.postpatch)) {\n            i(oldVnode, vnode);\n        }\n    }\n    return function patch(oldVnode, vnode) {\n        var i, elm, parent;\n        var insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (!isVnode(oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=snabbdom.js.map","import { h } from './h';\nfunction copyToThunk(vnode, thunk) {\n    thunk.elm = vnode.elm;\n    vnode.data.fn = thunk.data.fn;\n    vnode.data.args = thunk.data.args;\n    thunk.data = vnode.data;\n    thunk.children = vnode.children;\n    thunk.text = vnode.text;\n    thunk.elm = vnode.elm;\n}\nfunction init(thunk) {\n    var cur = thunk.data;\n    var vnode = cur.fn.apply(undefined, cur.args);\n    copyToThunk(vnode, thunk);\n}\nfunction prepatch(oldVnode, thunk) {\n    var i, old = oldVnode.data, cur = thunk.data;\n    var oldArgs = old.args, args = cur.args;\n    if (old.fn !== cur.fn || oldArgs.length !== args.length) {\n        copyToThunk(cur.fn.apply(undefined, args), thunk);\n        return;\n    }\n    for (i = 0; i < args.length; ++i) {\n        if (oldArgs[i] !== args[i]) {\n            copyToThunk(cur.fn.apply(undefined, args), thunk);\n            return;\n        }\n    }\n    copyToThunk(oldVnode, thunk);\n}\nexport var thunk = function thunk(sel, key, fn, args) {\n    if (args === undefined) {\n        args = fn;\n        fn = key;\n        key = undefined;\n    }\n    return h(sel, {\n        key: key,\n        hook: { init: init, prepatch: prepatch },\n        fn: fn,\n        args: args\n    });\n};\nexport default thunk;\n//# sourceMappingURL=thunk.js.map","export function vnode(sel, data, children, text, elm) {\n    var key = data === undefined ? undefined : data.key;\n    return { sel: sel, data: data, children: children, text: text, elm: elm, key: key };\n}\nexport default vnode;\n//# sourceMappingURL=vnode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexports.htmlDomApi = {\n    createElement: createElement,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    getTextContent: getTextContent,\n    isElement: isElement,\n    isText: isText,\n    isComment: isComment,\n};\nexports.default = exports.htmlDomApi;\n//# sourceMappingURL=htmldomapi.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar colonChar = 58;\nvar xChar = 120;\nfunction updateAttrs(oldVnode, vnode) {\n    var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;\n    if (!oldAttrs && !attrs)\n        return;\n    if (oldAttrs === attrs)\n        return;\n    oldAttrs = oldAttrs || {};\n    attrs = attrs || {};\n    // update modified attributes, add new attributes\n    for (key in attrs) {\n        var cur = attrs[key];\n        var old = oldAttrs[key];\n        if (old !== cur) {\n            if (cur === true) {\n                elm.setAttribute(key, \"\");\n            }\n            else if (cur === false) {\n                elm.removeAttribute(key);\n            }\n            else {\n                if (key.charCodeAt(0) !== xChar) {\n                    elm.setAttribute(key, cur);\n                }\n                else if (key.charCodeAt(3) === colonChar) {\n                    // Assume xml namespace\n                    elm.setAttributeNS(xmlNS, key, cur);\n                }\n                else if (key.charCodeAt(5) === colonChar) {\n                    // Assume xlink namespace\n                    elm.setAttributeNS(xlinkNS, key, cur);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n    }\n    // remove removed attributes\n    // use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n    // the other option is to remove all attributes with value == undefined\n    for (key in oldAttrs) {\n        if (!(key in attrs)) {\n            elm.removeAttribute(key);\n        }\n    }\n}\nexports.attributesModule = { create: updateAttrs, update: updateAttrs };\nexports.default = exports.attributesModule;\n//# sourceMappingURL=attributes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction updateClass(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldClass = oldVnode.data.class, klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (!klass[name]) {\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? 'add' : 'remove'](name);\n        }\n    }\n}\nexports.classModule = { create: updateClass, update: updateClass };\nexports.default = exports.classModule;\n//# sourceMappingURL=class.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction invokeHandler(handler, vnode, event) {\n    if (typeof handler === \"function\") {\n        // call function handler\n        handler.call(vnode, event, vnode);\n    }\n    else if (typeof handler === \"object\") {\n        // call handler with arguments\n        if (typeof handler[0] === \"function\") {\n            // special case for single argument for performance\n            if (handler.length === 2) {\n                handler[0].call(vnode, handler[1], event, vnode);\n            }\n            else {\n                var args = handler.slice(1);\n                args.push(event);\n                args.push(vnode);\n                handler[0].apply(vnode, args);\n            }\n        }\n        else {\n            // call multiple handlers\n            for (var i = 0; i < handler.length; i++) {\n                invokeHandler(handler[i], vnode, event);\n            }\n        }\n    }\n}\nfunction handleEvent(event, vnode) {\n    var name = event.type, on = vnode.data.on;\n    // call event handler(s) if exists\n    if (on && on[name]) {\n        invokeHandler(on[name], vnode, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateEventListeners(oldVnode, vnode) {\n    var oldOn = oldVnode.data.on, oldListener = oldVnode.listener, oldElm = oldVnode.elm, on = vnode && vnode.data.on, elm = (vnode && vnode.elm), name;\n    // optimization for reused immutable handlers\n    if (oldOn === on) {\n        return;\n    }\n    // remove existing listeners which no longer used\n    if (oldOn && oldListener) {\n        // if element changed or deleted we remove all existing listeners unconditionally\n        if (!on) {\n            for (name in oldOn) {\n                // remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener(name, oldListener, false);\n            }\n        }\n        else {\n            for (name in oldOn) {\n                // remove listener if existing listener removed\n                if (!on[name]) {\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n        }\n    }\n    // add new listeners which has not already attached\n    if (on) {\n        // reuse existing listener or create new\n        var listener = vnode.listener = oldVnode.listener || createListener();\n        // update vnode for listener\n        listener.vnode = vnode;\n        // if element changed or added we add all needed listeners unconditionally\n        if (!oldOn) {\n            for (name in on) {\n                // add listener if element was changed or new listeners added\n                elm.addEventListener(name, listener, false);\n            }\n        }\n        else {\n            for (name in on) {\n                // add listener if new listener added\n                if (!oldOn[name]) {\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n        }\n    }\n}\nexports.eventListenersModule = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners\n};\nexports.default = exports.eventListenersModule;\n//# sourceMappingURL=eventlisteners.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction updateProps(oldVnode, vnode) {\n    var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;\n    if (!oldProps && !props)\n        return;\n    if (oldProps === props)\n        return;\n    oldProps = oldProps || {};\n    props = props || {};\n    for (key in oldProps) {\n        if (!props[key]) {\n            delete elm[key];\n        }\n    }\n    for (key in props) {\n        cur = props[key];\n        old = oldProps[key];\n        if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n            elm[key] = cur;\n        }\n    }\n}\nexports.propsModule = { create: updateProps, update: updateProps };\nexports.default = exports.propsModule;\n//# sourceMappingURL=props.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nvar raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;\nvar nextFrame = function (fn) { raf(function () { raf(fn); }); };\nvar reflowForced = false;\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () { obj[prop] = val; });\n}\nfunction updateStyle(oldVnode, vnode) {\n    var cur, name, elm = vnode.elm, oldStyle = oldVnode.data.style, style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    var oldHasDel = 'delayed' in oldStyle;\n    for (name in oldStyle) {\n        if (!style[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = '';\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === 'delayed' && style.delayed) {\n            for (var name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== 'remove' && cur !== oldStyle[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    var style, name, elm = vnode.elm, s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    var s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    if (!reflowForced) {\n        vnode.elm.offsetLeft;\n        reflowForced = true;\n    }\n    var name, elm = vnode.elm, i = 0, compStyle, style = s.remove, amount = 0, applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    compStyle = getComputedStyle(elm);\n    var props = compStyle['transition-property'].split(', ');\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener('transitionend', function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nfunction forceReflow() {\n    reflowForced = false;\n}\nexports.styleModule = {\n    pre: forceReflow,\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle\n};\nexports.default = exports.styleModule;\n//# sourceMappingURL=style.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vnode_1 = require(\"./vnode\");\nvar htmldomapi_1 = require(\"./htmldomapi\");\nfunction toVNode(node, domApi) {\n    var api = domApi !== undefined ? domApi : htmldomapi_1.default;\n    var text;\n    if (api.isElement(node)) {\n        var id = node.id ? '#' + node.id : '';\n        var cn = node.getAttribute('class');\n        var c = cn ? '.' + cn.split(' ').join('.') : '';\n        var sel = api.tagName(node).toLowerCase() + id + c;\n        var attrs = {};\n        var children = [];\n        var name_1;\n        var i = void 0, n = void 0;\n        var elmAttrs = node.attributes;\n        var elmChildren = node.childNodes;\n        for (i = 0, n = elmAttrs.length; i < n; i++) {\n            name_1 = elmAttrs[i].nodeName;\n            if (name_1 !== 'id' && name_1 !== 'class') {\n                attrs[name_1] = elmAttrs[i].nodeValue;\n            }\n        }\n        for (i = 0, n = elmChildren.length; i < n; i++) {\n            children.push(toVNode(elmChildren[i], domApi));\n        }\n        return vnode_1.default(sel, { attrs: attrs }, children, undefined, node);\n    }\n    else if (api.isText(node)) {\n        text = api.getTextContent(node);\n        return vnode_1.default(undefined, undefined, undefined, text, node);\n    }\n    else if (api.isComment(node)) {\n        text = api.getTextContent(node);\n        return vnode_1.default('!', {}, [], text, node);\n    }\n    else {\n        return vnode_1.default('', {}, [], undefined, node);\n    }\n}\nexports.toVNode = toVNode;\nexports.default = toVNode;\n//# sourceMappingURL=tovnode.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction vnode(sel, data, children, text, elm) {\n    var key = data === undefined ? undefined : data.key;\n    return { sel: sel, data: data, children: children, text: text, elm: elm, key: key };\n}\nexports.vnode = vnode;\nexports.default = vnode;\n//# sourceMappingURL=vnode.js.map","import morphdom from 'morphdom';\nimport nanomorph from 'nanomorph';\nimport { DiffDOM } from 'diff-dom';\nimport * as snabbdom from 'snabbdom';\nimport toVNode from 'snabbdom/tovnode';\nimport { VNode } from 'snabbdom/vnode';\n\nconst patch = snabbdom.init([\n  // Init patch function with chosen modules\n  require('snabbdom/modules/class').default, // makes it easy to toggle classes\n  require('snabbdom/modules/props').default, // for setting properties on DOM elements\n  require('snabbdom/modules/style').default, // handles styling on elements with support for animations\n  require('snabbdom/modules/eventlisteners').default, // attaches event listeners\n  require('snabbdom/modules/attributes').default, // attaches event listeners\n]);\n\nlet currentVDom: VNode;\n\nconst ENGINE = 'morphdom' as 'morphdom' | 'nanomorph' | 'diffdom' | 'snabbdom';\nconsole.info('ENGINE:', ENGINE);\n\nconst dd = new DiffDOM();\n\nconst isLocalLink = (node: Node): boolean => {\n  let linkNode = node;\n  while (linkNode && linkNode.nodeName !== 'A') {\n    linkNode = linkNode.parentNode as Node;\n  }\n  return linkNode && !~((linkNode as HTMLAnchorElement).getAttribute?.('href') ?? '').indexOf('://');\n};\n\nconst isTextInput = (node: Node): node is HTMLInputElement =>\n  node.nodeName === 'INPUT' && ['email', 'text', 'password'].includes((node as HTMLInputElement).type);\n\nlet cache: Cache;\nwindow.caches.open('hybrid').then(c => (cache = c));\n\nconst morphdomOptions = {\n  onBeforeElUpdated: (from: Node, to: Node) => {\n    if (\n      from === document.activeElement &&\n      isTextInput(from) &&\n      isTextInput(to) &&\n      from.value !== from.getAttribute('value')\n    ) {\n      return false;\n    }\n    return !from.isEqualNode(to);\n  },\n};\n\nlet abortController: AbortController | null = null;\n\nconst parser = new DOMParser();\n\nconst getFirstValidResponse = <T>(requests: Promise<T>[]): Promise<T> =>\n  new Promise(resolve => requests.forEach(request => request.then(result => result && resolve(result))));\n\nconst handleRespone = (request: Request, mode: 'cache' | 'network', cacheRace: AbortController) => async (\n  response: Response | undefined,\n) => {\n  if (!response) {\n    return;\n  }\n  const text = await response.clone().text();\n  const start = performance.now();\n  if (response.headers.get('content-type')?.indexOf('text/html') === -1) {\n    window.location.href = response.url;\n    return;\n  }\n  const newDom = parser.parseFromString(text, 'text/html');\n  // The cache can be slower, than the network in some rare cases. We abort the\n  // rendering of cached responses in those situations to avoid overriding\n  // up-to-date responses with stale data.\n  if (cacheRace.signal.aborted) {\n    return;\n  }\n  if (mode === 'network') {\n    cache.put(response.url, response);\n    if (response.status === 301) {\n      cache.put(request.url, response);\n    }\n    cacheRace.abort();\n  }\n  switch (ENGINE) {\n    case 'nanomorph':\n      nanomorph(document.documentElement, newDom.documentElement);\n      break;\n    case 'morphdom':\n      morphdom(document.documentElement, newDom.documentElement, morphdomOptions);\n      break;\n    case 'diffdom': {\n      const diff = dd.diff(document.documentElement, newDom.documentElement);\n      const startApply = performance.now();\n      dd.apply(document.documentElement, diff);\n      const endApply = performance.now();\n      console.info('Application took', endApply - startApply);\n      break;\n    }\n    case 'snabbdom': {\n      const newVDom = toVNode(newDom.documentElement);\n      const startApply = performance.now();\n      patch(currentVDom, newVDom);\n      currentVDom = newVDom;\n      const endApply = performance.now();\n      console.info('Application took', endApply - startApply);\n      break;\n    }\n  }\n  const end = performance.now();\n  console.info('Transition took', end - start);\n  return response.url;\n};\n\nconst handleTransition = async (targetUrl: string) => {\n  abortController?.abort();\n  abortController = new AbortController();\n  const cacheRace = new AbortController();\n  document.body.classList.add('is-loading');\n  const request = new Request(targetUrl, {\n    credentials: 'same-origin',\n    redirect: 'follow',\n    signal: abortController.signal,\n  });\n  const cachedTransition = cache\n    ?.match(request)\n    .then(handleRespone(request, 'cache', cacheRace))\n    .catch(error => {\n      if (error.name !== 'AbortError') {\n        console.error(error, `Unable to resolve \"${targetUrl}\". Doing hard load instead...`);\n        window.location.href = targetUrl;\n      }\n    });\n  const networkTransition = fetch(request)\n    .then(handleRespone(request, 'network', cacheRace))\n    .catch(error => {\n      if (error.name !== 'AbortError') {\n        console.error(error, `Unable to resolve \"${targetUrl}\". Doing hard load instead...`);\n        window.location.href = targetUrl;\n      }\n    });\n  return getFirstValidResponse([cachedTransition, networkTransition]);\n};\n\nconst navigateTo = async (targetUrl: string) => {\n  // The final and target URLs can differ due to HTTP redirects.\n  const finalUrl = await handleTransition(targetUrl);\n  if (finalUrl) {\n    window.history.pushState(null, document.title, finalUrl);\n    window.scrollTo(0, 0);\n  }\n};\n\nconst handleClick = async (event: Event) => {\n  if (event?.target && isLocalLink(event.target as Node)) {\n    event.preventDefault();\n    navigateTo((event.target as HTMLAnchorElement).getAttribute('href') ?? '');\n  }\n};\n\nconst handleSubmit = async (event: Event) => {\n  event.preventDefault();\n  const form = event.target as HTMLFormElement;\n  const query = new URLSearchParams(new FormData(form) as any).toString();\n  await navigateTo(form.action + (query ? '?' + query : ''));\n};\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  currentVDom = toVNode(document.documentElement);\n  document.addEventListener('click', handleClick);\n  document.addEventListener('submit', handleSubmit);\n  window.onpopstate = (event: PopStateEvent) => handleTransition((event?.target as Window).location.href);\n});\n"],"sourceRoot":""}